1.一次sql执行过程如下：先创建DefaultSqlSession对象，然后通过SqlSession的select等方法执行sql，实际的执行sql的动作交给了executor的方法，executor实际执行sql的时候回去获取connection，
此时会调用dataSource的getConnection方法获取连接,执行完sql方法后，会关闭connection（这里的关闭连接其实就是只把连接返回到连接池dataSource中）.
2.MapperProxy这个是生成代理类的关键类.
3.BaseExecutor中的一级缓存，用途一般来说是一个sqlSession连续执行多个相同的sql语句的时候，后面的相同sql执行直接从一级缓存中获取，而不用再查询数据库.但是实践中注意的问题：
如果同一个sqlSession在执行后面相同的sql之前执行了commit动作，那么一级缓存就被清空了。紧接着的这次相同的sql执行就会是查询数据库(因为一级缓存已空).
4.关于一级缓存：当创建了一个SqlSession对象时，MyBatis会为这个SqlSession对象创建一个新的Executor执行器，而缓存信息就被维护在这个Executor执行器中。
5.不管使用什么数据源，生成的sqlSession对象都是DefaultSqlSession类的实例，每次sql都创建DefaultSqlSession的情况下，一级缓存是随着sqlSession的销毁而销毁的
6.要开启二级缓存，要满足三个条件:第一个条件:使用cacheExecutor,3.4.1版本的该参数默认情况下是开启的.第二个条件：缓存空间@CacheNamespace,第三个条件@Options(useCache=true,),默认select的情况下是满足的.
如果已经开启了二级缓存，那么相同的select查询会走缓存，但是如果select中间插入有该缓存命名空间内的update，insert等语句的话，二级缓存会失效。
总结来说：如果多机访问同一个数据库的话，不要开启二级缓存，因为另一台机器更新了数据之后会使数据库中的数据变新，然而初始机器中仍然访问的是它那台机器的旧的二级缓存的数据.
所以综合来说，应该应用层自己构造自己应用层的缓存。不要使用myibatis的二级缓存.